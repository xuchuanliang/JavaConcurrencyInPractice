#显示锁

## Lock与ReentrantLock
>Lock提供了一种无条件、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁方式都是显示的。
>ReentrantLock实现了Lock接口，并提供了与synchronized相同的互斥性和内存可见性。在获取ReentrantLock时，有着与进入同步代码块相同的内存语义，在释放ReentrantLock时，同样有着与退出同步代码块相同的内存语义。
- 轮询锁与定时锁
>可定时和可轮询的锁获取模式是由tryLock实现的，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。在内置锁中，死锁是一个很严重的问题，恢复程序的唯一方法是重新启动程序，而防止死锁的唯一方法就是在构造程序时，
避免出现不一致的锁顺序。可定时和可轮询的锁提供了另一种选择：避免死锁的发生。
- 可中断的锁获取操作
>在ReentrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者一个公平的锁。在公平的锁上，线程将按照他们发出的请求顺序来获得锁，但在非公平的锁上，
则允许插队：当一个线程请求到非公平锁时，如果在发出请求的同时，该锁的状态变为可用，那么这个线程则跳过队列中所有等待线程并获得这个锁。
>在竞争激烈的情况下，非公平锁的性能高于公平锁的性能的一个原因是：在恢复一个被挂起的线程与改线程真正开始运行之间存在严重的延迟。

##在synchronized与ReentrantLock之间进行选择
>在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，
公平队列，以及非结构的锁。否则，还是应该优先使用synchronized

##读写锁
