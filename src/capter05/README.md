#基础构建模块
##同步容器类
- 同步容器类包括Vectory和Hashtable，这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
- 正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。
##并发容器
- Java提供了多种并发容器类来改进同步容器的性能，同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性；并发容器是针对多个线程并发访问设计的，ConcurrentHashMap用来替代同步且基于散列的Map,
以及CopyOnWriteArrayList用于在遍历操作为主要操作的情况下替代同步的List,在新的ConcurrentMap接口中增加了对一些常见复合操作的支持，例如若没有则添加/替换以及有条件删除等
- 通过并发容器来替代同步容器，可以极大的提到伸缩性并降低风险。
- Java5.0增加两种新的容器类型，Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。它提供了几种实现，包括:ConcurrentLinkedQueue,这是一个传统的先进先出队列，以及PriorityQueue，这是一个非并发的优先队列。Queue上的操作不会阻塞，如果
队列为空，那么获取元素的操作将返回空值。BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现了一个可用的元素。如果队列已满，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间，
在生产者-消费者设计模式中，阻塞队列是非常有用的。
###ConcurrentHashMap
- ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁。在这种机制中，任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map,
并且一定数量的写入线程可以并发的修改Map，提供了更高吞吐量，损失更小性能。 返回的迭代器具有弱一致性；Hashtable和synchronizedMap是独占锁，ConcurrentHashMap是分段锁；只由当应用程序需要加锁Map进行独占访问时，才应该放弃使用ConcurrentHashMap，否则都应该使用ConcurrentHashMap
- 由于ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作。
- CopyOnWriteArrayList用来替代同步List，CopyOnWriteArraySet用来替代同步Set，Copy-On-Write写入时复制，底层通过复制的方式保证线程安全性
##阻塞队列和生产者-消费者模式
- put()和take():生产和消费
- 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：他们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。
- FIFO：先入先出
- BlockingQueue的实现：LinkedBlockingQueue和ArrayBlockingQueue时FIFO队列，分别与LinkedList和ArrayList类似，但是比同步的list拥有更好的并发性能；PriorityBlockingQueue是一个按照优先级排序的队列，若需要按照某种顺序而不是FIFO来处理元素时，这个队列
比较合适，支持Comparator；SynchronousQueue，实际上不是一个队列，不为队列维护存储空间，直接交付工作至消费者，仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。
##阻塞方法和中断方法
- interrupt()方法（中断）
##同步工具类
- 同步工具类都包含一些特定的结构化属性：他们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效的等待同步工具类进入到预期状态。
###闭锁
- 闭锁是一种同步工具类，可以延迟线程的进度直到其达到终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。
当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态，闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。
- CountDownLatch是一种灵活的闭锁实现，闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量，countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到linguistic，或者等待中的线程中断，或者等待超时。
###FutureTask
- FutureTask在Executor框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。
###信号量
- 计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量，计数信号量还可以用来实现某种资源池，或者对容器施加边界。
- Semaphore
###栅栏
- 栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。
- CyclicBarrier
##构建高效且可伸缩的结果缓存






