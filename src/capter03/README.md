#对象的共享
##可见性
- 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确结论。
- 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作和写操作的线程都必须在同一个锁上同步。
- volatile变量
- 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用，如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile
- 加锁机制既可以保证可见性又可以确保原子性，而volatile变量只能确保可见性
- 当且紧当满足以下所有条件时，才应该使用volatile：对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值；该变量不会与其他状态变量一起纳入不变形条件中；在访问变量时不需要加锁；
##发布和逸出
- 发布一个对象的意思是指，是对象能够在当前作用域之外的代码中使用，当某个不应该发布的对象被发布时，这种情况称为逸出
- 不要在构造过程中使用this逸出，也就是不要在对象构造函数没有执行完的情况下（也就是对象还没初始化完成的情况下）将该对象（this）有暴漏出去的可能。
##线程封闭
###Ad-hoc线程封闭
- Ad-hoc线程封闭是指维护线程封闭性的职责完全由程序实现来承担（太过脆弱）
###栈封闭
###ThreadLocal类
- ThreadLocal是将线程中的某个值与保存值的对象关联起来，实现了线程封闭。
##不变性
- 不可变对象一定是线程安全的
- 满足以下条件，对象才是不可变：1.对象创建以后其状态就不能修改；2.对象的所有域都是final类型；3.对象是正确创建的（在对象的创建期间，this引用没有逸出）
- 任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步
- 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：在静态初始化函数中初始化一个对象的引用；
将对象的引用保存到volatile类型的域或者AtomicReferance对象中；将对象的引用保存到某个正确构造对象的final类型域中；将对象的引用保存到一个由锁保护的域中；
- 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象
- 对象的发布需求取决于他的可变性：不可变对象可以通过任意机制来发布；事实不可变对象必须通过安全方式来发布；可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来
- 在并发程序中使用和共享对象时，可以使用一些使用的策略，包括：1.线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改；2.只读共享：在没有额外同步的情况下，
共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象；3.线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过访问对象的
共有接口来进行访问而不需要进一步的同步；4.保护对象：被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。


