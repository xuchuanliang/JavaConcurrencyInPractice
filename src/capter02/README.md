#线程安全性
- 当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误，有三种方式可以修复该问题：不在程序之间共享该状态变量、将状态变量修改为不可变的变量、在访问状态变量时使用同步
P13 什么是线程安全
##什么是线程安全性
- 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么称这个类是线程安全的。
- 无状态对象一定是线程安全的
##原子性
###竞态条件
- 最常见的竟态条件类型就是先检查后执行操作：首先观察到某个条件为真，然后根据这个观察结果采取相应的动作，但事实上，在你观察到这个结果以及开始执行操作之间，观察结果可能会变得无效，从而导致各种问题
- 另一种常见的竟态条件是读取-修改-写入
- 要避免竟态条件的问题，就必须在某个线程修改该变量时，通过某种方式阻止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取或修改状态，而不是在修改状态的过程中。
- 有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身来说），这个操作是一个以原子方式执行的操作。
- 复合操作：包括一组必须以原子方式执行的操作以确保线程安全性。
###实例：延迟初始化中的竟态条件
###复合操作
- 原子操作是指对于访问同一个状态的所有操作（包括操作本身）来说，这个操作是一个以原子方式执行的操作。
- 我们将先检查后执行以及读取-修改-写入等操作统称为符合操作：包含了一组必须以原子方式执行的操作以确保线程安全性
- java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换，如：用AtomicLong代替Long
##加锁机制
- 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量
###内置锁
- Java提供一种内置的锁机制来支持原子性：同步代码块
- 每个java对象都可以用作一个实现同步的锁，这些锁称为内置锁或监视器锁，线程在进入同步代码块前自动获得锁，并且在退出代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出的异常退出。获得内置锁的唯一途径
就是进入由这个锁保护的同步代码块或方法。
- Java的内置锁相当于互斥锁，意味着最多只有一个线程能持有这种锁。
###重入
- 当某个线程请求一个由其他线程持有的锁时，发出请求的线程会阻塞。然尔，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由他自己持有的锁时，那么这个请求就会成功。重入意味着获取锁的操作粒度是线程而不是调用，重入的一种实现方式是，
为每个锁关联一个获取计数器和一个所有者线程，当计数器为0时，这个锁就被认为是没有被其他任何线程持有。当这个线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数器值置为1，如果同一个线程再次获取这个锁，计数器将递增，
而当线程退出同步代码块时，计数器将相应的递减，当计数器为0时，这个锁将被释放。
- 获取到子类的锁时会自动获得父类的锁，如果内置锁不可重入，那么在调用super的方法时，理论上就会等待获得父类锁而导致死锁，所以重入是指拿了锁，再调用该锁包含的代码可以不用再次等待拿锁
##用锁来保护状态
- 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的
- 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁
- **一种常见加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步。**
- 对于每个包含多个变量的不变性条件，其中涉及到的所有变量都需要由同一个锁来保护
##活跃性与性能
- 要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中，应该尽可能将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而这些操作的执行过程中，其他线程可以访问共享状态。

