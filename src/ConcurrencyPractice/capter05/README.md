#基础构建模块
##同步容器类
-        Collections.synchronizedList(new ArrayList<>());
-        Collections.synchronizedMap(new HashMap<>());
-        Collections.synchronizedSet(new HashSet<>());
-        Collections.synchronizedCollection(new ArrayList<>());
- 同步容器类包括Vectory和Hashtable等由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
- 正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。
- 同步容器类都是线程安全的，但是在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的复合操作包括：迭代（反复访问元素，直到遍历完容器中的所有元素）、跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算，
例如：若没有则添加，在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发的修改容器时，它们可能会出现线程安全问题。
- 长时间的对容器进行加锁会降低程序的可伸缩性，持有锁时间越长，那么在锁上的竞争越激烈。
- 加锁能够防止迭代器抛出ConcurrentModificationException，但是实际情况中可能存在隐含的迭代操作，导致线程并发问题，如打印某个集合，底层会迭代打印集合中的每个元素，那么这种隐式迭代可能导致线程安全问题；容器的hashCode和equals等方法
也会间接的执行迭代器操作，当容器作为另一个容器的元素或键时，就会出现隐式迭代的情况。同时containAll，removeAll和retainAll等方法，以及把容器作为参数的的构造函数，都会对容器进行迭代。所有的这些间接的迭代操作都可能会抛出ConcurrentModificationException
- 通过跟踪Collections.synchronizedList(new ArrayList<>())等创建同步容器类的源码发现，底层是在Collections中存在一个对应的静态内部类，同时使用对固定对象锁的方式，使用synchronized (mutex)的方式进行加锁，如类似如下方法：
public int lastIndexOf(Object o) {
            synchronized (mutex) {return list.lastIndexOf(o);}
        }
- **同步容器类是上面的Collections静态工厂方法创建的类，跟踪源码发现同步容器是将所有对容器状态的访问进行串行化，以实现他们的线程安全性，这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。**
##并发容器
- 同步容器和并发容器，
- Java提供了多种并发容器类来改进同步容器的性能，同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性；并发容器是针对多个线程并发访问设计的，ConcurrentHashMap用来替代同步且基于散列的Map,
以及CopyOnWriteArrayList用于在遍历操作为主要操作的情况下替代同步的List,在新的ConcurrentMap接口中增加了对一些常见复合操作的支持，例如若没有则添加/替换以及有条件删除等
- **通过并发容器来替代同步容器，可以极大的提到伸缩性并降低风险。**
- java5.0新增ConcurrentHashMap用来替代同步Map；新增CopyOnWriteArrayList用来替代同步List，
- Java5.0增加两种新的容器类型，Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。
它提供了几种实现，包括:ConcurrentLinkedQueue,这是一个传统的先进先出队列，以及PriorityQueue，这是一个非并发的优先队列。Queue上的操作不会阻塞；
如果队列为空，那么获取元素的操作将返回空值。
- BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现了一个可用的元素。如果队列已满，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间，在生产者-消费者设计模式中，阻塞队列是非常有用的。
- java6引入ConcurrentSkipListMap和ConcurrentSkipListSet，分别替代SortedMap和SortedSet

###ConcurrentHashMap
- ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为**分段锁**。
在这种机制中，任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map,并且一定数量的写入线程可以并发的修改Map，提供了更高吞吐量，损失更小性能。 
- **返回的迭代器具有弱一致性；Hashtable和synchronizedMap是独占锁，ConcurrentHashMap是分段锁；只由当应用程序需要加锁Map进行独占访问时，才应该放弃使用ConcurrentHashMap，否则都应该使用ConcurrentHashMap**
- 由于ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作。
- CopyOnWriteArrayList用来替代同步List，CopyOnWriteArraySet用来替代同步Set，Copy-On-Write写入时复制，底层通过复制的方式保证线程安全性

###额外的原子Map操作

##CopyOnWriteArrayList
- 写入时复制（Copy-On-Write）容器的线程安全性在于，只要正确地发布发布一个事实不可变的对象，那么在访问该对象时就不需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的
迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于他不会被修改，因此在对其进行同步时只需确保数组内容可见行。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰。
- 弊端：每当修改容器时都会复制底层数组，特别是容器规模比较大时，需要一定的开销，仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

##阻塞队列和生产者-消费者模式
- put()和take():生产和消费
- 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：他们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。
- FIFO：先入先出
- BlockingQueue的实现：LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，分别与LinkedList和ArrayList类似，但是比同步的list拥有更好的并发性能；PriorityBlockingQueue是一个按照优先级排序的队列，若需要按照某种顺序而不是FIFO来处理元素时，这个队列
比较合适，支持Comparator；SynchronousQueue，实际上不是一个队列，不为队列维护存储空间，直接交付工作至消费者，仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。

###串行线程封闭
- 对于可变对象，生产者-消费者这种设计和阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全的发布该对象来转移所有权。在转移所有权后，也只有另一个线程能获得
这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象的状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，因此对象将被封闭在新的线程中，新的所有者线程可以对该对象进行任意修改，因此它具有独占的访问权。

###双端队列和工作密取
- java6增加两种容器类型：Deque和BlockingDeque，它们分别对Queue和BlockingQueue进行了扩展，Deque是一个双端队列，实现了在队列头和队列尾的高效插入和删除，具体实现包括ArrayDeque和LinkedBlockingDeque。
- 双端队列适用于另一种设计模式：工作密取。在工作密取模式中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密的获取工作。密取工作模式比传统的生产者-消费者模式具有更高的伸缩性，
因为工作者线程不会在单个共享的任务队列上发生竞争。

##阻塞方法和中断方法
- interrupt()方法（中断）

##同步工具类
- 在容器类中，阻塞队列是一种独特的类：他们不仅能作为保存对象的容器，还能协调生产者和消费者等线程之间的控制流。
- 👆同步工具类可以是任何一个对象，只要它根据自己的状态来协调线程的控制流。阻塞队列可以作为同步工具类，其他类型的同步工具类还包括信号量（Semaphore），栅栏（Barrier）以及闭锁（Latch）。
- 同步工具类都包含一些特定的结构化属性：他们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效的等待同步工具类进入到预期状态。

###闭锁
- 闭锁是一种同步工具类，可以延迟线程的进度直到其达到终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。
当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态，闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。
- CountDownLatch是一种灵活的闭锁实现，闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量，countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到达到零，或者等待中的线程中断，或者等待超时。

###FutureTask
- FutureTask在Executor框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。

###信号量
- 计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量，计数信号量还可以用来实现某种资源池，或者对容器施加边界。
- Semaphore中管理着一组虚拟许可（permit），许可的初始数量可以通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并可以在使用以后释放许可。如果
没有许可，那么acquire将阻塞直到有许可（或者直到中断或者超时）。release方法将返回一个许可信号量。
- 计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore，二值信号量可以作为互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个唯一许可，谁就拥有了互斥所。

###栅栏
- 闭锁是一次性对象，一旦进入终止状态，就不能被重置。
- 栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。
- CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，它在并行迭代算法中非常有用：这种算法可以将一个问题拆分成一系列相互独立的子问题。当线程到达栅栏位置时调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果
所有线程都达到了栅栏位置，那么栅栏打开，此时所有的线程都将被释放，而栅栏将重置以便下次使用。如果对await调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是被打破了，所有阻塞的调用都将终止并抛出BrokenBarrierException。
如果成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来选举产生一个领导线程，并在下次迭代中由该领导线程执行一些特殊工作。CyclicBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，
当成功通过栅栏时会在一个子任务线程中执行它，但在阻塞线程被释放之是不能被执行的。

##构建高效且可伸缩的结果缓存
##小结
- 可变状态是至关重要的，所有的并发问题都可以归纳为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性
- 尽量将域声明为final类型，除非需要他们是可变的
- 不可变对象一定是线程安全的，不可变对象能极大的降低并发编程的复杂性。他们更为简单而且安全，可以任意共享而无须使用加锁或者保护性复制等机制
- 封装有助于管理复杂性，在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但将数据封装在对象中，更容易维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
- 用锁来保护每个可变变量
- 当保护同一个不可变性条件中的所有变量时，要使用同一个锁
- 在执行复合操作时，要持有锁
- 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题


















