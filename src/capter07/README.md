#取消与关闭
##任务取消
- 如果外部代码能够在某个操作正常完成之前将其提前置入“完成”状态，那么这个操作可以成为可取消的
- Thread中：interrupt方法能够中断目标线程；isInterrupt方法能够返回目标线程的中断状态；静态的interrupted方法将清除当前线程的中断状态。
- 清除中断状态，抛出InterruptedException表示阻塞操作由于中断而提前结束
###中断
- 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。即它并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程
在下一个合适的时刻中断自己。
- 通常中断时实现取消的最合理方式
###中断策略
- 由于每个线程拥有各自的中断策略，因此除非你知道中断对改线程的含义，否则就不应该中断这个线程。
- 只由实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求
###通过future来实现取消
- Future标识一个任务的生命周期，拥有一个cancel方法，该方法带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功。（这只是表示任务能否接受中断，
而不是表示任务任务能否能检测并处理中断。）如果mayInterruptIfRunning为true并且任务当前正在某个线程中运行，那么这个线程能被中断。如果这个参数为false，那么
意味着“若任务还没有启动，就不要运行它”，这种方式应用于那些不处理中断的任务中。
###处理不可中断的阻塞
###采用newTaskFor来封装非标准的取消

##停止基于线程的服务
- 对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法
###关闭ExecutorService
###毒丸对象
- 另一种关闭生产者-消费者服务的方式就是使用毒丸对象：毒丸是指一个放在队列上的对象，其含义是：当得到这个对象时，立即停止。
###实例：只执行一次的服务
###守护线程
- 线程可分为两种：普通线程和守护线程；在JVM启动时创建的所有线程中，处理主线程以外，其他的线程都是守护线程，当创建一个新线程时，新线程将继承它的线程守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。
- 普通线程和守护线程之间的差异仅在于当线程退出时发生的操作，当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常的退出操作。当JVM停止时，所有仍然存在的
守护线程都将被抛弃，既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出，守护线程通常不能用来替代应用程序管理程序中各个服务的声明周期。