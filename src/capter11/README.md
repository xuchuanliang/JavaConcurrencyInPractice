#性能和可伸缩性
##对性能的思考
- 应用程序的性能可以采用多个指标来衡量，例如服务时间、延迟时间、吞吐率、效率、可伸缩性以及容量等。其中一些指标（服务时间、等待时间）用于衡量程序的运行速度，即某个指定的任务单元
需要多块才能处理完成。另一些指标（生产量、吞吐量）用于程序的处理能力，即在计算资源一定的情况下，能完成多少工作
- 可伸缩性指的是：当增加计算资源时（如CPU，内存，存储容量或I/O带宽），程序的吞吐量或者处理能力能相应的增加。
- 大多数提高单线程程序性能的技术，往往都会破坏可伸缩性
- 避免不成熟的优化，首先使程序正确，然后再提高运行速度
- 性能调优要以测试为基准，不要猜测

##Amdahl定律
- Amdahl定律描述的是：在增加计算资源的的情况下、程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。
- 在所有的并发程序中都包含一些串行部分

##线程引入的开销
###上下文切换
>如何可运行的线程数量大于cpu的数量，那么操作系统最终将会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。这将导致一次上下文的切换，在这个过程中将保存当前运行线程的执行上下文，并将新的调度进来的线程的执行上下文设置为当前上下文。
>在线程调度中需要访问由操作系统和JVM共享的数据结构，上下文切换带来的开销包含JVM和操作系统的开销，当一个新的线程被切换进来时，它所需要的数据可能不在当前处理器的缓存中，因此上下文切换将导致一些缓存的缺失，首次调度时会更缓慢。
###内存同步
>不要过度担心非竞争同步带来的开销。这个基本机制已经非常快了，并且JVM还能进行而外的优化以进一步降低或消除开销。因此，我们应该将优化重点放在那些发生锁竞争的地方。
###阻塞

##减少锁的竞争
>在并发程序中，对可伸缩性的主要威胁就是独占方式的资源锁<br>
>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁，有两个因素将影响在锁上发生竞争的可能性：锁的请求频率，以及每次持有该锁的时间。如果二者乘积很小，则大多数获取锁的操作不会发生竞争。
- 有三种方式可以降低锁的竞争程度：
>减少锁的持有时间<br>
>降低锁的请求频率<br>
>使用带有协调机制的独占锁，这些机制允许更高的并发性<br>
###缩小锁的范围
- 降低发生竞争可能性的一种有效方式就是尽可能缩短锁的持有时间
###减少锁的粒度
- 锁分解
>另一种减小锁的持有时间的方式是降低请求锁的频率（从而减少发生竞争的可能性）。这可以通过锁分解和锁分段等技术来实现，在这些技术中将采用多个相互独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况，
这些技术能减少锁操作的粒度，并能实现更高的伸缩性。<br>
>如果一个锁要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁请求的频率
