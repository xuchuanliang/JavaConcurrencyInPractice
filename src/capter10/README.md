#避免活跃性危险
- 让线程睡眠尽量不要使用Thread.sleep()方法了，应该是会用TimeUtil类
##死锁
- 当线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远等待下去，这种情况是最简单的死锁形式（抱死）
###锁顺序死锁
- 两个线程试图以不同的顺序来获得相同的锁，那么会产生死锁现象。如果按照相同的顺序来请求锁，就不会出现循环加锁依赖性，因此不会产生死锁
- 如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁（这可能会产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。
###开放调用
- 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用。依赖于开放调用的类通常能够表现出更好的行为，并且与那些在调用方法时需要持有锁的类相比，也更易于编写。这种通过开放调用来避免
死锁的方法，类似于采用封装机制来提供线程安全的方法：虽然在没有封装的情况下也能够确保构建线程安全的程序，但对一个使用了封装的程序进行线程安全分析，要比分析没有使用封装的程序容易的多。同理，
分析一个完全依赖于开放调用的程序的活跃性，要比分析那些不依赖开放调用的程序活跃性简单。通过尽可能的开放调用，将更易于找出那些需要获取多个锁的代码路径，因此也就更容易确保采用一致的顺序获取锁。
###在协作对象之间发生的死锁