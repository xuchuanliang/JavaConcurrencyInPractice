#对象的组合
##设计线程安全的类
- 在设计线程安全类的过程中，需要包含以下三个基本要素：1.找出构成对象状态的所有变量；2.找出约束状态变量的不变性条件；3.建立对象状态的并发访问管理策略
- 同步策略定义了如何在不违背对象不变形条件或后验条件的情况下对其状态的访问进行协同，同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。
- 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁
- 封闭机制更易于构建线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时无序检查整个程序
##实例封闭
- 当一个对象被封装到另一个对象中时，能够访问被封装对象所有代码路径都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以县城安全的方式来使用非线程安全的对象。
- 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁
- 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无需检查整个程序
###Java监视器模式
- 遵循Java监视器模式的对象会把对象的所有状态都封装起来，并由对象的**内置锁**来保护
##线程安全性的委托
- 通过观察Collections.unmodifiableMap();的源码发现，this.m = m;，也就说明返回的map和传入的map指向类了同一块内存，意味着对map的改动会在两个map中都反应出来
###当委托失效时
- 如果某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个符合操作都可以委托给状态变量。
如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。
- 如果一个状态变量时线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全的发布这个变量
##在现有的线程安全类中添加功能
- 1.修改原始类，在原始类中增加方法
- 2.扩展该类，但是需要和父类保持同一把锁，否则会出现线程安全问题，无法保证原子性操作，同时该方法太脆弱，当父类更换同步策咯时，该扩展类的线程安全就会出现问题
- 3.客户端加锁机制，即扩展该类的功能，但是需要与扩展的类保持同一把锁，否则会出现线程安全问题
- 客户端加锁机制与扩展类机制都是将派生类的行为与基类的实现耦合在一起，扩展类会破坏实现的封装性，客户端加锁会破同步策略的封装性。
- 4.组合